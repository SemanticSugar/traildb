#!/usr/bin/env python
"""
tdb info TRAILDB ...
tdb get TRAILDB ... [-i ID ...]
tdb cat TRAILDB ... [-f FIELD ...] [-p "FIELD='VAL' and FIELD!='VAL' ...]
tdb lex TRAILDB ... [-f FIELD ...]
tdb merge TRAILDB ... [-o OUTDB]
"""

import os
import sys
import argparse
import itertools
import ply

from traildb import TrailDB, TrailDBConstructor

def tabify(iter, fmt='%s'):
    return '\t'.join(fmt % x for x in iter)

def help():
    print(__doc__.strip())

def info(args, opts):
    for arg in args:
        tdb = TrailDB(arg)
        print '%s' % arg
        print ' # trails:                    %12d' % tdb.num_trails
        print ' # events:                    %12d' % tdb.num_events
        print ' # fields:                    %12d' % tdb.num_fields
        for f in tdb.fields[1:]:
            print ' # -%-25s %12d' % (f + ':', tdb.lexicon_size(f))
        tmin, tmax = tdb.time_range(ptime=True)
        print u' \u2265 time:               %s' % tmin
        print u' \u2264 time:               %s' % tmax

def get(args, opts):
    for arg in args:
        tdb = TrailDB(arg)
        fields = opts.field or tdb.fields
        for id in opts.id or [0]:
            id = int(id)
            cookie = tdb.cookie(id)
            for event in tdb.trail(id, ptime=True):
                print '%s\t%s' % (cookie, '\t'.join(str(getattr(event, f)) for f in fields))

def lex(args, opts):
    for arg in args:
        tdb = TrailDB(arg)
        for field in opts.field or tdb.fields[1:]:
            for value in tdb.lexicon(field):
                print '%s\t%s' % (field, value)

def cat(args, opts):
    filter_expr = None
    if opts.predicates:
        filter_expr = []
        lexer = filter_lexer()
        parser = filter_parser()
        for predicate in opts.predicates:
            lexer.input(predicate)
            filter_expr.append(parser.parse(predicate, lexer = lexer))

    for arg in args:
        tdb = TrailDB(arg)
        if opts.field:
            for cookie, trail in tdb.crumbs(filter_expr = filter_expr):
                for event in trail:
                    try:
                        print '%s\t%s' % (cookie, tabify(getattr(event, f) for f in opts.field))
                    except IOError:
                        # stdout closed, probably we're writing into 'head'
                        return
        else:
            for cookie, trail in tdb.crumbs(filter_expr = filter_expr):
                try:
                    print cookie, trail
                except IOError:
                    # stdout closed, probably we're writing into 'head'
                    return

def merge(args, opts):
    for n, arg in enumerate(args):
        tdb = TrailDB(arg)
        if n == 0:
            cons = TrailDBConstructor(opts.outdb, tdb.fields[1:])
        cons.append(tdb)
    cons.finalize()


lexer_tokens = ('EQ', 'NEQ', 'VALUE', 'OR')
def filter_lexer():
    tokens   = lexer_tokens
    reserved = { 'or'  : 'OR' }
    t_OR     = r'or'
    t_EQ     = r'='
    t_NEQ    = r'!='
    t_ignore = ' '
    def t_VALUE(t):
        r'\w+|\'\w+\''
        t.type = reserved.get(t.value, 'VALUE')
        if t.value[0] == "'" and t.value[-1] == "'":
            t.value = t.value.strip("'")
        return t

    def t_error(t): raise Exception("illegal token: %s" %t)

    import ply.lex
    return ply.lex.lex()

def filter_parser():
    tokens = lexer_tokens

    def p_expr(p):
        """expression : expression OR expression"""
        p[0] = []
        p[0].extend(p[1])
        p[0].extend(p[3])

    def p_eq(p):
        """expression : VALUE EQ VALUE"""
        p[0] = [{'field': p[1], 'value': p[3], 'op': 'equal'}]

    def p_neq(p):
        """expression : VALUE NEQ VALUE"""
        p[0] = [{'field': p[1], 'value': p[3], 'op': 'notequal'}]

    def p_error(p):
        raise Exception("Syntax error")

    import ply.yacc
    return ply.yacc.yacc(debug = False)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--id',
                        action='append',
                        help="id to get")
    parser.add_argument('-f', '--field',
                        action='append',
                        help="name of field to operate on")
    parser.add_argument('-p', '--predicates',
                        action='append',
                        help="predicate used for filtering")
    parser.add_argument('-o', '--outdb',
                        default='a.tdb',
                        help="name of output dbs for split / merge")
    parser.add_argument('-n', '--num-parts',
                        default=1,
                        type=int,
                        help="number of parts")
    opts, args = parser.parse_known_args(sys.argv[1:])
    cmd, args = args[0] if args else 'help', args[1:]
    if cmd == 'help':
        return help()
    return eval(cmd)(args, opts)

if __name__ == '__main__':
    main()
